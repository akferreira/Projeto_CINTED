<!doctype html>
<html>
<head>
  <title>Network</title>
  <script type="text/javascript" src="https://unpkg.com/vis-network@latest/dist/vis-network.min.js"></script>
  <link href="https://unpkg.com/vis-network@latest/dist/vis-network.min.css" rel="stylesheet" type="text/css" />
  <style type="text/css">
    #mynetwork {
      width: 1200px;
      height: 800px;
      border: 1px solid lightgray;
    }
  </style>
</head>
<body>
<div id="mynetwork"></div>

<script type="text/javascript" src="jquery.min.js"></script>
<script src="https://unpkg.com/neo4j-driver@1.7.6/lib/browser/neo4j-web.min.js"></script>
<script type="text/javascript">


var mapCoursePosition =  new Map;

function insert_node(id, label,group,hide,xcord, ycord, courseid = null){
console.log(`${hide} hide`);
    if(hide === undefined){
        hide = false;
    }

    try{
       
        node_info.add({id : id, label: label, group: group,courseid : courseid, y: ycord, x: xcord
});
         console.log(`node ${id} inserted! ${hide}`);
    }
  
    catch(e){
    
            if(group === "Resources") node_info.update([{id : id, hidden: hide}]);
        
    
           console.log(`resources ${group === "Resources"} ${group}`);
    }
}

function insert_edge(idA,idB,count,log10_timedelta,hide){
    if(hide === undefined){
        hide = false;
    }

     try{
    r_info.add({from: idA, to: idB,width: count,length: 100 + 15*log10_timedelta});
    //r_info.add({from: idA, to: idB,width: count,length: 100 + 1*log10_timedelta});
  }
  
  catch(e){
  
    r_info.update([{id : id, hidden: hide}]);
  }
}

function getEdgeBetweenNodes(node1,node2) {
    edges =  r_info.get().filter(function (edge) {
        return (edge.from === node1 && edge.to === node2 )|| (edge.from === node2 && edge.to === node1)
    });
    
    return edges.length > 0;
    
};

function average_delta(){}

function create_graph_access_order(result, hide,courseid){
        const singleRecord = result.records[0];
        const node = singleRecord.get(0);
        
        if(hide === undefined){
        hide = false;
        }
        
        var hideA;
        var hideB = hide;
        var xcord;
        
        console.log(`${hide} hide`);

        for (record of result.records){
            idA = record.get("id(A)").toNumber();
            idB = record.get("id(B)").toNumber();
        
            var nameA;

            if(record.get('typeA') == "Student"){
                nameA =  record.get('A').properties.trajectory_name;
                hideA = false;
            }
            
            else if(record.get('typeA') == "Courses"){
                nameA =  record.get('A').properties.coursename;
                hideA = false;
//                 xcord = mapCoursePosition.get(idA);
            
            }


            else{
                nameA = record.get('A').properties.name;
                hideA = hide;
            }



            nameB = record.get('B').properties.name;

            
            
            

            const count = record.get('r').properties.count.toNumber();
            var groupA = record.get('typeA')[0];
            var groupB = record.get('typeB')[0];

            
            timedeltas = record.get('r').properties.timedeltas;
            var total = 0;

            for (timedelta of timedeltas){
            total += parseInt(timedelta,10);
            }

            average = total/timedeltas.length;

          //  console.log(average);
            timeformatted = new Date(average * 1000)

            log10_timedelta = Math.log10(average+1);

           // console.log(Math.log10(average+1));
           
            console.log("abc");
        
            insert_node(idA,nameA,groupA,0, 1,hideA);
            insert_node(idB,nameB,groupB,0, 2,hideB);
            
//             if(hideB == true) insert_node(idB,nameB,groupB,true);
//             else insert_node(idB,nameB,groupB,false);
            
            console.log(`${idA} . ${idB}`);
         //    console.log(`${hideA} hide2`);
          //   console.log(`${hideB} hide3`);
            
            if(getEdgeBetweenNodes(idA,idB) == false){
                insert_edge(idA,idB,count,log10_timedelta,hide);
                }
            //console.log(getEdgeBetweenNodes(idA,idB));
            
        
        }


}

function create_graph_course_order(result){
   var course_count = 0;

    for (record of result.records){
            var nameA;
            course_count+=1;

            if(record.get('typeA') == "Student"){
                nameA =  record.get('A').properties.trajectory_name;
            }
            
            else if(record.get('typeA') == "Courses"){
                nameA =  record.get('A').properties.coursename;
            
            }

            else{
                nameA = record.get('A').properties.name;
            }



            nameB = record.get('B').properties.name;
            courseB = Number(record.get('B').properties.courseid)
            
            

            idA = record.get("id(A)").toNumber();
            idB = record.get("id(B)").toNumber();
            
            var xcord = course_count*150+200
//             mapCoursePosition.set(idA, xcord+idA);
//             mapCoursePosition.set(idB, xcord+idB);
            
            var groupA = record.get('typeA')[0];
            var groupB = record.get('typeB')[0];
        
            insert_node(idA,nameA,groupA,false,xcord+idA,0);
            insert_node(idB,nameB,groupB,false,xcord+idB,0,courseB);
            insert_edge(idA,idB,1,1);
            
        
        }



}


const driver = neo4j.v1.driver("bolt://localhost:7687", neo4j.v1.auth.basic("neo4j", "cinted"));
const session = driver.session();
const resultPromise = session.run(
  "match (A)-[r:MATRICULADO]->(B) return A,LABELs(A) as typeA,r,B,LABELs(B) as typeB,id(A),id(B),B.courseid"
);

var node_info = new vis.DataSet();
var r_info = new vis.DataSet();

var mapAccess = new Map;

resultPromise.then(result => {
    session.close();
    create_graph_course_order(result);


    console.log(node_info);


    // create a network
    //nodes: nodes,
    //  edges: edges,
    //
    var container = document.getElementById('mynetwork');
    var data = {
        nodes: node_info,
        edges: r_info,
        options: options
    };
    var options = {

    groups: {
    
    Courses: {

        shape: 'circle',
        color: '#FFA07A',

        widthConstraint: { maximum: 120 }
        
    },

    Student: {

        shape: 'circle',
        color: '#228B22',

        widthConstraint: { maximum: 120 }
        
    },
    Resources: {

        shape: 'circle',

        widthConstraint: { maximum: 120 }
        
    }
    },
//     layout: {
//      clusterThreshold: 10,
//       hierarchical: {
//         direction: "UD",
//          
//       }
//     },
//     
   
layout:{
        randomSeed: 1,
        improvedLayout: true,
    
                },
//  physics: {
//                     forceAtlas2Based: {
//                         gravitationalConstant: -50,
//                         centralGravity: 0.005,
//                         springLength: 230,
//                         springConstant: 0.18
//                     },
//                     maxVelocity: 146,
//                     solver: 'forceAtlas2Based',
//                     timestep: 0.35,
//                     stabilization: {
//                         enabled:true,
//                         iterations:2000,
//                         updateInterval:5
//                     }
//                 },
    

//     physics: {
//         enabled: true,
//         barnesHut: {
//             "avoidOverlap": 4
//         },
//         hierarchicalRepulsion: {
//             centralGravity: 0.0,
//             springLength: 50,
//             springConstant: 0.01,
//             nodeDistance: 200,
//             damping: 0.09
//         }
// 
//         //     hierarchicalRepulsion: {
//         //         centralGravity: 0.0,
//         //         nodeDistance: 30,
//         //     },
//         //      solver: 'hierarchicalRepulsion'
//         },


        edges:{
        arrows: 'to',
        color: 'red',
        font: '12px arial #ff0000',
        scaling:{
            label: true,
        },
        shadow: true,
        smooth: true,
    }



    };
    var network = new vis.Network(container, data, options);
    network.on( 'click', function(properties) {
    var ids = properties.nodes;
    var clickedNodes = node_info.get(ids);
    console.log('clicked nodes:', clickedNodes);
    
    for (node of clickedNodes){
        if(node['courseid'] != null){
            console.log(`Course id is ${node['courseid']} ....`)
        }
    
        
    }
        var ids = properties.nodes;
        var clickedNodes = node_info.get(ids);
        courseid = clickedNodes[0]['courseid']
        
        if(courseid == null){
            return;
        }
        
        console.log('clicked nodes:', clickedNodes);
        const resultPromise = session.run(
        `match (C:Student {userid : '55'})-[r:ACCESS_ORDER]->(B:Resources  {courseid : '${courseid}'}),(A:Courses {courseid : '${courseid}'}) return A,LABELs(A) as typeA,r,B,LABELs(B) as typeB,id(A),id(B) union match (A:Resources  {courseid : '${courseid}'})-[r:ACCESS_ORDER]->(B:Resources  {courseid : '${courseid}'}) return A,LABELs(A) as typeA,r,B,LABELs(B) as typeB,id(A),id(B)`
        );

        resultPromise.then(result => {
        session.close();
        console.log(result)
        
        var already_added = mapAccess.has(courseid);
        var hide;
        if(already_added == true) {
            hide = !mapAccess.get(courseid);
            mapAccess.set(courseid, hide);
        }
        else {
            hide = false;
            mapAccess.set(courseid, false);
        }
        console.log(`${already_added}//${hide}//course ${courseid}`);
        
        create_graph_access_order(result, hide,courseid);
        network.body.emitter.emit('_dataChanged')
        network.redraw();
        console.log("finished")
       });
        
        
    });

    // on application exit:
    driver.close();
});


  
</script>
</body>
</html>
